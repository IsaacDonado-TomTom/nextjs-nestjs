# Run app
1. git clone
2. `cd into project`
3. `npm run dev`

# Table of contents
1. [Create a next.js app](#create-nextjs-app)
2. [Add new page](#add-new-page)
3. [New route / directory](#new-route-directory)
4. [Static website generation](#static)
5. [Server-side rendering application](#ssr)
6. [Environment variables](#env-variables)
7. [Easy, less dynamic way of implementing layouts](#easy-layouts)
8. [Implementing dynamic layouts](#dynamic-layouts)
9. [Nestjs for backend, Nextjs for frondend](#nestjs-backend)
10. [Enable e2e testing](#e2e-testing)






<a name="create-nextjs-app"></a>
# Create Next.js App
To create your first next.js app based on typescript and using npm enter this in terminal:

```bash
npx create-next-app nextjs-blog --use-npm --typescript
```

This generates the project folder and within a few important folders.

**pages**: next.js does automatic file/directory based routing within the pages folder, this is one of the neat features.

**public**: In this folder we can serve public assets to access such as favorite icon logos, etc.

**styles**: In this folder we can store css styles and they'll be accessible and applicable on pages automatically.



Notice how \_app.tsx wraps the whole website, delete everything being returned in index.tsx except the `<div />` container that contains the special `<Head></Head>` notation. 

```tsx
const Home: NextPage = () => {
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
    </div>
  )
}
```

and wrap the return of the function in \_app.tsx with codeblocks like this.

```tsx
import '../styles/globals.css'
import type { AppProps } from 'next/app'

function MyApp({ Component, pageProps }: AppProps) {
  return (
  <>
  HELLO WORLD.
  <Component {...pageProps} />
  </>
  );
}

export default MyApp

```

Now to run in development mode

```bash
npm run dev
```

in case you want to export production ready static files: 
```bash
npm run build && next export
```




<a name="add-new-page"></a>
# Add new page
In order to add a new page, create a new tsx file in the pages directory and we're required to export a default function in each page file.

hello.tsx:
```tsx
import { NextPage } from 'next';

const HelloPage: NextPage = () => 
{
    return (
        <h1>Hello amigos!</h1>
    );
}

export default HelloPage;
```

Now this new page should be accessible through localhost:port/hello






<a name="new-route-directory"></a>
# New route / directory
Let's make a new directory route that lists some data, and an infinite amount of routes to pages that can be dynamically routed.

Create a folder in the pages directory named after the route.. for example.

localhost:3000/example

and create an index.tsx with a function returning the content.

pages/example/index.tsx
```tsx
import { NextPage } from 'next';

const Example: NextPage = () => 
{
    return (
        <h1>The example page.</h1>
    );
}

export default Example;
```

And to make a route dynamic, use this notation for the file naming:

`pages/example/[id].tsx`

In order to access the query parameters we need to import the `{ useRoute }` from `next/router` and use it like this:

pages/example/[id].tsx
```tsx
import { NextPage } from 'next';
import { useRouter } from 'next/router';

const Dynamic: NextPage = () => 
{
    const router = useRouter();
    const { id } = router.query;

    return (
        <h1>The example route to: { id }</h1>
    );
}

export default Dynamic;
```





<a name="static"></a>
# Generate static content on build time
Let's use this [harry potter API](https://hp-api.herokuapp.com/) to generate some static content on the homepage.

We need to export an `async` function called getStaticProps which will return a type GetStaticProps (from next) .. We also pass the properties we need as parameters to our index page function.

pages/index.tsx
```tsx
import type { GetStaticProps, NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'

const Home: NextPage = function ({hpstudents}: any)
{
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <div>{ JSON.stringify(hpstudents) }</div>
    </div>
  )
}

export const getStaticProps: GetStaticProps = async function (context)
{
    const res: any = await fetch("http://hp-api.herokuapp.com/api/characters/students");
    const results: any = await res.json();

    return {
      props: {
        hpstudents: results,
      },
    };
}

export default Home
```

Using the method above we preload/prerender any json we need an pass it to the page route, and use the data in our template, hence the name GetStaticProps.. 

Now if we visit our homepage we'll see a huge string with lots of data about the hogwarts students, let's copy all of the text and introduce a useful tool called [quicktype.io](https://quicktype.io) .. Paste all of the text into quick type. 

We should have some interfaces, add them to a new file in the root directory called types.ts, but we should also create an interface for receiving only the data we're interested in, and a custom interface within that interface which we'll call Info, for pagination.

/types.ts
```ts
// OUR CUSTOM INTERFACES

export interface GetHpStudents {
    info: Info;
    results: [Student];
}

export interface Info {
    count: number;
    pages: number;
    next: string;
    prev: null;
}

// END OF CUSTOM INTERFACES, THE REST IS GENERATED BY QUICKTYPE.IO

export interface Student {
    name:             string;
    alternate_names:  string[];
    species:          Species;
    gender:           Gender;
    house:            House;
    dateOfBirth:      DateOfBirth;
    yearOfBirth:      number | string;
    wizard:           boolean;
    ancestry:         Ancestry;
    eyeColour:        EyeColour;
    hairColour:       HairColour;
    wand:             Wand;
    patronus:         Patronus;
    hogwartsStudent:  boolean;
    hogwartsStaff:    boolean;
    actor:            string;
    alternate_actors: string[];
    alive:            boolean;
    image:            string;
}

export enum Ancestry {
    Empty = "",
    HalfBlood = "half-blood",
    Muggleborn = "muggleborn",
    PureBlood = "pure-blood",
}

export enum DateOfBirth {
    Empty = "",
    The01031980 = "01-03-1980",
    The05061980 = "05-06-1980",
    The11081981 = "11-08-1981",
    The13021981 = "13-02-1981",
    The19091979 = "19-09-1979",
    The30071980 = "30-07-1980",
    The31071980 = "31-07-1980",
}

export enum EyeColour {
    Black = "black",
    Blue = "blue",
    Brown = "brown",
    Dark = "dark",
    Empty = "",
    Green = "green",
    Grey = "grey",
}

export enum Gender {
    Female = "female",
    Male = "male",
}

export enum HairColour {
    Black = "black",
    Blond = "blond",
    Blonde = "blonde",
    Brown = "brown",
    Dark = "dark",
    Empty = "",
    Red = "red",
    Sandy = "sandy",
}

export enum House {
    Empty = "",
    Gryffindor = "Gryffindor",
    Hufflepuff = "Hufflepuff",
    Ravenclaw = "Ravenclaw",
    Slytherin = "Slytherin",
}

export enum Patronus {
    Boar = "boar",
    Empty = "",
    Hare = "hare",
    Horse = "horse",
    JackRussellTerrier = "Jack Russell terrier",
    Otter = "otter",
    Stag = "stag",
    Swan = "swan",
}

export enum Species {
    Human = "human",
}

export interface Wand {
    wood:   Wood;
    core:   Core;
    length: number | string;
}

export enum Core {
    DragonHeartstring = "dragon heartstring",
    Empty = "",
    PhoenixFeather = "phoenix feather",
    UnicornHair = "unicorn hair",
    UnicornTailHair = "unicorn tail-hair",
}

export enum Wood {
    Ash = "ash",
    Cherry = "cherry",
    Empty = "",
    Hawthorn = "hawthorn",
    Holly = "holly",
    Vine = "vine",
    Willow = "willow",
    Yew = "yew",
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toStudent(json: string): Student[] {
        return cast(JSON.parse(json), a(r("Student")));
    }

    public static studentToJson(value: Student[]): string {
        return JSON.stringify(uncast(value, a(r("Student"))), null, 2);
    }
}

function invalidValue(typ: any, val: any, key: any = ''): never {
    if (key) {
        throw Error(`Invalid value for key "${key}". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ: any): any {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ: any): any {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val: any, typ: any, getProps: any, key: any = ''): any {
    function transformPrimitive(typ: string, val: any): any {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs: any[], val: any): any {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases: string[], val: any): any {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ: any, val: any): any {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue("array", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val: any): any {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue("Date", val);
        }
        return d;
    }

    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {
        if (val === null || typeof val !== "object" || Array.isArray(val)) {
            return invalidValue("object", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === "any") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === "object" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty("arrayItems")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty("props")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== "number") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val: T, typ: any): any {
    return transform(val, typ, jsToJSONProps);
}

function a(typ: any) {
    return { arrayItems: typ };
}

function u(...typs: any[]) {
    return { unionMembers: typs };
}

function o(props: any[], additional: any) {
    return { props, additional };
}

function m(additional: any) {
    return { props: [], additional };
}

function r(name: string) {
    return { ref: name };
}

const typeMap: any = {
    "Student": o([
        { json: "name", js: "name", typ: "" },
        { json: "alternate_names", js: "alternate_names", typ: a("") },
        { json: "species", js: "species", typ: r("Species") },
        { json: "gender", js: "gender", typ: r("Gender") },
        { json: "house", js: "house", typ: r("House") },
        { json: "dateOfBirth", js: "dateOfBirth", typ: r("DateOfBirth") },
        { json: "yearOfBirth", js: "yearOfBirth", typ: u(0, "") },
        { json: "wizard", js: "wizard", typ: true },
        { json: "ancestry", js: "ancestry", typ: r("Ancestry") },
        { json: "eyeColour", js: "eyeColour", typ: r("EyeColour") },
        { json: "hairColour", js: "hairColour", typ: r("HairColour") },
        { json: "wand", js: "wand", typ: r("Wand") },
        { json: "patronus", js: "patronus", typ: r("Patronus") },
        { json: "hogwartsStudent", js: "hogwartsStudent", typ: true },
        { json: "hogwartsStaff", js: "hogwartsStaff", typ: true },
        { json: "actor", js: "actor", typ: "" },
        { json: "alternate_actors", js: "alternate_actors", typ: a("") },
        { json: "alive", js: "alive", typ: true },
        { json: "image", js: "image", typ: "" },
    ], false),
    "Wand": o([
        { json: "wood", js: "wood", typ: r("Wood") },
        { json: "core", js: "core", typ: r("Core") },
        { json: "length", js: "length", typ: u(3.14, "") },
    ], false),
    "Ancestry": [
        "",
        "half-blood",
        "muggleborn",
        "pure-blood",
    ],
    "DateOfBirth": [
        "",
        "01-03-1980",
        "05-06-1980",
        "11-08-1981",
        "13-02-1981",
        "19-09-1979",
        "30-07-1980",
        "31-07-1980",
    ],
    "EyeColour": [
        "black",
        "blue",
        "brown",
        "dark",
        "",
        "green",
        "grey",
    ],
    "Gender": [
        "female",
        "male",
    ],
    "HairColour": [
        "black",
        "blond",
        "blonde",
        "brown",
        "dark",
        "",
        "red",
        "sandy",
    ],
    "House": [
        "",
        "Gryffindor",
        "Hufflepuff",
        "Ravenclaw",
        "Slytherin",
    ],
    "Patronus": [
        "boar",
        "",
        "hare",
        "horse",
        "Jack Russell terrier",
        "otter",
        "stag",
        "swan",
    ],
    "Species": [
        "human",
    ],
    "Core": [
        "dragon heartstring",
        "",
        "phoenix feather",
        "unicorn hair",
        "unicorn tail-hair",
    ],
    "Wood": [
        "ash",
        "cherry",
        "",
        "hawthorn",
        "holly",
        "vine",
        "willow",
        "yew",
    ],
};

```

Now we'll set the type of our results to the our custom interface in our getStaticProps function, and in our index page function, notice our return type is a generic, we'll pass our custom type to the generic and say that our `hpstudents` are of that type.

Then we'll map through our students and display the name, I added a unique ID to the function just because `<li />` requires a mandatory unique key.

pages/index.tsx
```tsx
import type { GetStaticProps, NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'
import { GetHpStudents, Student } from '../types'

const Home: NextPage<{hpstudents: Student[]}> = function ({hpstudents})
{
  let id: number = 0;
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <ul>
        { hpstudents.map(
          function (student)
          {
            id++;
            return <li key={ JSON.stringify(id) }><img src={student.image} style={{width: "50px", height: "50px", borderRadius: "50%"}} />{student.name}</li>;
          }
        ) }
      </ul>
    </div>
  )
}

export const getStaticProps: GetStaticProps = async function (context)
{
    const res: any = await fetch("http://hp-api.herokuapp.com/api/characters/students");
    const results: GetHpStudents = await res.json();

    return {
      props: {
        hpstudents: results,
      },
    };
}

export default Home

```




<a name="ssr"></a>
# Server-side rendering App
Up until this point all of the data fetching has been done on the client side, to make this run on the server and test it, lets just edit the index.tsx file and remove the `getStaticProps` function.

We're now making `getServerSideProps` it will return a `GetServerSideProps` type, which is imported from `next`.

```tsx
import type { GetStaticProps, GetServerSideProps, NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'
import { GetHpStudents, Student } from '../types'

const Home: NextPage<{hpstudents: Student[]}> = function ({hpstudents})
{
  let id: number = 0;
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <ul>
        { hpstudents.map(
          function (student)
          {
            id++;
            return <li key={ JSON.stringify(id) }><img src={student.image} style={{width: "50px", height: "50px", borderRadius: "50%"}} />{student.name}</li>;
          }
        ) }
      </ul>
    </div>
  )
}

export const getServerSideProps: GetServerSideProps = async function (context)
{
    const res: any = await fetch("http://hp-api.herokuapp.com/api/characters/students");
    const results: GetHpStudents = await res.json();
    console.log("Fetching from harry potter API!\n");

    return {
      props: {
        hpstudents: results,
      },
    };
}

export default Home

```

`npm run start` and when you visit localhost:3000, something will be logged to the terminal. proof it's running the fetching function on the server side, even if you refresh, the console log will not display the message. `*Run npm run start to test and NOT npm run dev ... dev will console log regardless*`

We can use the best of both worlds for which ever case we need now. 





<a name="env-variables"></a>
# Using environment variables

To get started using environment variables, create a file in the root directory of the project called `.env.local` ... Now to access this as attributes we run `process.env.[NAME]`.. 

Look at a simple example:

./.env.local
```text
PRIVATE_KEY=my-secret-string
NEXT_PUBLIC_PUBLIC_KEY=my-public-string
```

*NOTICE* .. The only way to make these variables displayable is by adding NEXT\_PUBLIC\_ prefix to the variable. This is a security feature.

pages/index.tsx
```tsx
import type { NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'

const Home: NextPage = function ()
{
  const logIt: any = function ()
  {
    console.log(`Private key: ${process.env.PRIVATE_KEY}\nPublic key: ${process.env.NEXT_PUBLIC_PUBLIC_KEY}\n`);
  }
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <p>
        Private key: { process.env.PRIVATE_KEY }
      </p>
      <p>
        Public key: { process.env.NEXT_PUBLIC_PUBLIC_KEY }
      </p>
      <button onClick={logIt}>Console log keys</button>
    </div>
  )
}


export default Home

```

This web app logs to the console the environment variables, and tried to display both.





<a name="easy-layouts"></a>
# Easy, less dynamic way of implementing layouts
An easy way we could implement layouts in our nextjs web app is by 

1. Create directory in the next.js project folder called components
2. Create a .tsx file within components called `Layout.tsx`
3. In the Layout.tsx file, create a function that receives a `{ children }` object of type `{ children: React.ReactNode }` and returns the layout.
4. Within the return value of the Layout function in Layout.tsx, include the `{ children }` object wherever the rest of the page should go.
5. Wrap your app with `<Layout />` tags in \_app.tsx

project-directory/components/Layout.tsx
```tsx
import React from 'react'; 

function Layout({ children }: { children: React.ReactNode })
{
    return (
        <div>
            <nav>
                Page one
            </nav>
            { children }
        </div>
    );
}
export default Layout
```


project-directory/pages/\_app.tsx
```tsx
import '../styles/globals.css'
import type { AppProps } from 'next/app'
import Layout from '../components/Layout';

function MyApp({ Component, pageProps }: AppProps) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  );
}

export default MyApp
```

project-directory/pages/index.tsx
```tsx
import type { NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'

const Home: NextPage = function ()
{
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <p>
        Welcome to a next website.
      </p>
    </div>
  )
}


export default Home
```





<a name="dynamic-layouts"></a>
# Dynamic layouts
The simple way of obtaining layout functionality is fine if you need the same layout throughout the whole web app, but in case your pages have different layouts, then another approach is needed. 

1. We keep the layout created within the components page
2. We create a constant called getLayout in our main app function in \_app.tsx,  we assign some logic related to out Component object explained in the example below.
3. Create a type called `AppPropsWithLayout` that extends from `AppProps`
4. This new type's `Component` property is equal to another type that we'll be creating, NextPageWithLayout.
5. As suggested above, we create a type called NextPageWithLayout, which extends from NextPage, and a property getLayout, if exists within our page will be assigned some logic.
6. Change the type of the object passed to our main app function, from AppProps to the newly created AppPropsWithLayout
7. Wrap the return value of out main function in \_app.tsc in a getLayout function.
8. In each individual page, if a layout is needed, we assign the getLayout function, a function that returns the page property passed as an argument wrapped in the layout of our choice.

project-directory/pages/\_app.tsx
```tsx
import '../styles/globals.css';
import type { AppProps } from 'next/app';
import Layout from '../components/Layout';
import { ReactElement, ReactNode } from 'react';
import type { NextPage } from 'next';

type NextPageWithLayout = NextPage & {
  getLayout?: (page: ReactElement) => ReactNode;
}

type AppPropsWithLayout = AppProps & {
  Component: NextPageWithLayout
}

function MyApp({ Component, pageProps }: AppPropsWithLayout) {
  const getLayout = Component.getLayout ??  ((page) =>  page);

  return (
      getLayout(<Component {...pageProps} />)
  );
}

export default MyApp
```

project-directory/pages/index.tsx
```tsx
import type { NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import Layout from '../components/Layout'
import styles from '../styles/Home.module.css'

const Home: NextPage = function ()
{
  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <p>
        Welcome to a next website.
      </p>
    </div>
  )
}

Home.getLayout = function getLayout(page: typeof Home)
{
  return (
    <Layout>
      { page }
    </Layout>
  );
}


export default Home
```




<a name="nestjs-backend"></a>
# Guide on Nestjs for backend, Nextjs for frondend
First set up a nestjs app ..
```bash
nest new [project-name] --package-manager npm
...

cd [project-name] && npm start:dev
```

Next up, install next and react and nestjs/config module and create a `view module`

```bash
npm install next react react-dom
...
npm i --save @nestjs/config
...
npm install --save-dev @types/react
...

nest g module view
nest g controller view
nest g service view
```


Import ConfigService into main App Module and allow it to be accessed globally

project-directory/src/app.module.ts
```tsc
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ViewModule } from './view/view.module';
import { View } from './view';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [ViewModule, ConfigModule.forRoot({
    isGlobal: true,
  })],
  controllers: [AppController],
  providers: [AppService, View],
})
export class AppModule {}
```


Alternatively, and better imo, import it to the view module without setting it to global.


Create two separate directories in `src` where we'll store client side files, and server side files, call them `client & server`.

Import necessary tools into the view controller and set the routes accordingly: 

project-directory/src/view/view.controller.ts
```tsc
import { Controller, Get, Res, Req } from '@nestjs/common';
import { Request, Response } from 'express';
import { ViewService } from './view.service';

@Controller('/')
export class ViewController {
  constructor(private viewService: ViewService) {}

  @Get('home')
  public async showHome(@Req() req: Request, @Res() res: Response) {
    await this.viewService.handler(req, res);
  }

  @Get('_next*')
  public async assets(@Req() req: Request, @Res() res: Response) {
    await this.viewService.handler(req, res);
  }

  @Get('favicon.ico')
  public async favicon(@Req() req: Request, @Res() res: Response) {
    await this.viewService.handler(req, res);
  }
}
```

Next we'll use existing functions next gives us to create a nextjs frontside server and access it through nestjs routes in the view service.

Import necessary tools from next, nestjs, express and add the following to the view service in order to tell nestjs where to look for our nextjs pages

```tsc
import { Injectable, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import createServer from 'next';
import { NextServer } from 'next/dist/server/next';
import { Request, Response } from 'express';

@Injectable()
export class ViewService implements OnModuleInit {
    private server: NextServer;

    constructor(private configService: ConfigService) {}

    async onModuleInit(): Promise<void> {
      try {
        this.server = createServer({
          dev: this.configService.get<string>('NODE_ENV') !== 'production',
          dir: './src/client',
        });
        await this.server.prepare();
      } catch (error) {
        console.error(error);
      }
    }

    handler(req: Request, res: Response) {
      return this.server.getRequestHandler()(req, res);
    }
}
```

Next pages will be looked for under a subdirectory of src/client called `pages`, create it and let's add a home page to match the /home route in the view controller.

project-directory/src/client/pages/home.tsx
```tsx
import React from 'react';
import { NextPage } from 'next';

const Home: NextPage = () => {
  return (<h1>Hello!</h1>);
};

export default Home;
```

We're almost done separating our client/server before we can make this work we have to do some editing of nestjs and nextjs config files and we must move everything related to the server into the server folder. the src folder must contain only two folders, client and server.

Create a file in project-directory/src/client/ called `.eslintrc.js`

project-directory/src/client/.eslintrc.js
```js
module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'src/client/tsconfig.json',
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'prettier/@typescript-eslint',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
    '@typescript-eslint/no-unused-vars': ['warn', { 'argsIgnorePattern': '^_' }]
  },
};
```


Change the source of the server in nest-cli.json

project-directory/nest-cli.json
```json
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src/server"
}
```

Create a file in project-directory/src/client/ called `next-env.d.ts`

project-directory/src/client/next-env.d.ts
```ts
/// <reference types="next" />
/// <reference types="next/types/global" />
```

Create a file in project-directory/src/client/ called `next.config.js`

project-directory/src/client/next.config.js
```js
module.exports = {
  distDir: '../../.next',
};
```

Modify the following script in package.json

project-directory/package.json
```json
{
  "scripts": {
    "build": "nest build && cd src/client && next build",
  }
}
```

Modify project-directory/tsconfig.json
```json
{
  "include": ["src/server"],
}
```

Modify tsconfig.json of client to support typescript

project-directory/src/client/tsconfig.json
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve"
  },
  "include": [
    "next-env.d.ts",
    "next.config.js",
    "pages/**/*.ts",
    "pages/**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
```

Done! Now we can use nestjs to serve front and backend. We can make use of nestjs @Guards for next.js pages and we can make use of SSR with Next’s getServerSideProps to query the API within our pages files.





<a name="e2e-testing"></a>
# Enable e2e testing
One last thing to finish, at the moment e2e testing won't work, we need to make a parent module that integrates the main App module and the new View module nicely and make e2e testing work.


Remove ViewModule from the imports in main app.module

project-directory/src/server/app.module.ts
```tsc
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [ConfigModule.forRoot({
    isGlobal: true,
  })],
  controllers: [AppController],
  providers: [AppService, View],
})
export class AppModule {}
```

Remove the main app module as our app main entry point and replace it with server module we'll be creating in the server folder

project-directory/src/server/main.ts
```ts
import { NestFactory } from '@nestjs/core';
import { ServerModule } from './server.module'

async function bootstrap() {
  const app = await NestFactory.create(ServerModule);
  await app.listen(3000);
}
bootstrap();
```

Create the actual server module that will wrap the app and the frontend.

project-directory/src/server/server.module.ts
```ts
import { Module } from '@nestjs/common';

import { AppModule } from './app.module';
import { ViewModule } from 'src/server/view/view.module';

@Module({
  imports: [AppModule, ViewModule],
})
export class ServerModule {}
```

DONE. Nest.js is serving nestjs content and a next.js site.
